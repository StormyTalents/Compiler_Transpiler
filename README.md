# Compiler_Transpiler

<h3>Parses and compiles a custom programming language into C++.</h3>

<p>I've created my own C-based scripting language. While it strongly resembles other languages, it has features that others alone do not have. It includes Java's static type checking, C++'s primitive types, Python's binary operations and nested functions, and JavaScript's expression evaluation and objects.</p>

<p>It is designed to overcome some of the more annoying aspects of C++, such as its inability to be used as a scripting language and resolve functions defined later in the file or nested within other functions.</p>

<p>Simultaneously, it retains many of the great features of C++ as well as features from other languages like Python and JavaScript, all while keeping the speed C++ is known for. This is possible because the compiler uses <a href="http://www.antlr.org/">ANTLR</a> and a <a href="https://github.com/ewadkins/Compiler/blob/master/src/com/ericwadkins/parser/Compiler.g4">context-free grammar</a> to parse the code and then transpile it directly into C++.</p>

<p>I'm still working on this project and looking to add more features. Below is a brief example of a the language implementation which demonstrates some of the features of the language so far, followed by the abstract syntax tree generated by the parser.</p>

```
print(test(0));                           // Use as scripting language

unsigned short test(int n) {              // unsigned short return type
    long double x = 2;
    if (n) {                              // if n != 0
        return (unsigned short) x ** n;   // x to the power of n
    }
    return tryAgain();

    unsigned short tryAgain() {           // Nested function
        return test(n + 1);
    }
}
```

![image](https://github.com/StormyTalents/Compiler_Transpiler/assets/98739389/c4c93b8a-067e-49d3-b3dd-d4baaa7feac6)

```
// Binary Search
int binarySearch(int[] arr, int value, int left, int right) {
    while (left <= right) {
        int middle = (left + right) / 2;
        if (arr[middle] == value)
            return middle;
        else if (arr[middle] > value)
            right = middle - 1;
        else
            left = middle + 1;
    }
    return -1;
}
```

![image](https://github.com/StormyTalents/Compiler_Transpiler/assets/98739389/7b8ac9fb-b20b-4396-b82d-d35bf8c0721a)

```
// Ackermann Function
int ackermann(int m, int n) {
    if (m == 0) return n + 1;
    if (n == 0) return ackermann(m - 1, 1);

    return ackermann(m - 1, ackermann(m, n - 1));
}
```

![image](https://github.com/StormyTalents/Compiler_Transpiler/assets/98739389/f79623dd-78fc-45da-9cd8-0f367c47e906)
